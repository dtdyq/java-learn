package jvm.gc;
/**
 * 
 * @author dtdyq
 * 常用垃圾收集算法简单介绍：
 * 1、标记-清除算法  mark-sweep：
 * 算法分为“标记”和“清除”两个阶段：首先标记所有需要回收的对象，在标记完成后统一回收所有
 * 被标记的对象，这是后续其他算法的基础
 * 	不足之处：
 * 		效率问题：标记和清除两个过程的效率都不高
 * 		空间问题：标记清除后会产生大量不连续的内存碎片
 * 
 * 2、复制算法copying：
 * 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存使用完了，就
 * 将活着的对象复制到另一半内存，这样就不用再考虑内存碎片等复杂情况，只是代价是可用内存
 * 变为了原来的一半
 * 
 * 3、标记-整理算法 mark-compact：
 * 复制算法在对象存活率较高的情况下需要进行较多的复制，效率会变低
 * 标记-整理算法的标记过程仍然是标记-清除算法一样，但后续步骤不是直接对可回收对象进行回收
 * 而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存
 * 
 * 分代收集算法 Generationnal collection：
 * 分代收集算法是将堆内存分为新生代和老年代，这样可以根据各个年代的特点使用最适合的算法
 * 对于新生代，对象死亡率较高，可以使用复制算法，而老年代的对象存活的时间很久，可以使用
 * 标记-清除算法或标记-整理算法
 * 
 * 
 */
public class GC {

}
