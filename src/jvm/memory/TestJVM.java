package jvm.memory;
/**
 * 
 * @author dtdyq
 *jvm内存模型：
 *程序计数器：当前线程所执行字节码的行号指示器，每条线程都有独立的程序计数器，这个内存区域
 *也是jvm中唯一没有规定任何OutOfMemoryError的区域
 *
 *java虚拟机栈：也是线程私有的，生命周期和线程相同，描述的是java方法执行的内存模型，每个方法
 *在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等
 *		局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型
 *			double和long会占用两个局部变量空间
 *			方法运行期间不会改变局部变量表的大小
 *		该区域的异常：OutOfMemoryError：无法申请到足够的内存
 *				     StackOverflowError：请求的栈深度大于虚拟机要求的最大深度
 *
 *本地方法栈：与虚拟机栈功能基本相同，不过本地方法栈为native方法提供服务，也定义了
 *StackOverflowError和OutOfMemoryError异常
 *
 *java堆：也称为gc堆，java虚拟机所管理的内存中最大的一块，被所有线程共享，此区域唯一的作用
 *是存放对象实例，是垃圾收集的主要工作区域，
 *		可通过-Xmx和-Xms设置堆最大和最小内存，当两者相同时表示堆大小不能改变
 *
 *方法区：是各个线程共享的内存区域，用于存储已被jvm加载的类信息、常量、静态变量、即时编译器
 *编译后的代码等数据
 *		-XX:MaxPermSize:设置方法区的上限
 *
 *运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，该区域有动态性
 *，运行期间也可以将新的常量放入池中，常量池无法申请到内存时会抛出OutOfMemoryError异常
 *
 *直接内存：分配堆外内存，用于nio中的操作
 *
 */
public class TestJVM {
	
}












