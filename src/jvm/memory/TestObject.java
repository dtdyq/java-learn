package jvm.memory;
/**
 * 
 * @author dtdyq
 *对象创建过程：
 *
 *1、虚拟机执行到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用
 *并检查这个类是否已经被加载、解析和初始化过，如果没有，则首先执行类加载过程
 *2、类加载结束后，jvm为为新生对象分配内存，对象所需内存的大小在类加载完成后即可完全确定
 *		根据堆内存使用是否规整，对内存的分配分为指针碰撞和空闲列表两种方式，这也取决于
 *		垃圾回收算法的不同
 *		
 *		同步问题：分配内存的同步处理，一种使用同步方法，一种是为每个线程在内存中预先分配
 *		一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer），可以使用
 *		-XX：+/-UseTLAB指定是否使用本地线程分配缓冲
 *3、内存分配完成后，虚拟机会讲分配到的内存初始化为0，，这一步操作保证了对象的实例字段在java
 *代码中可以不赋初始值就直接使用
 *4、jvm对对象进行必要的设置，如这个对象是哪个类的实例，如何才能找到类的元信息、对象的哈希码
 *对象的gc分代年龄等，这些信息存放在对象头中
 *
 *5、new操作已经完成，接下来是init操作，将对象按照程序员的意向进行初始化，对象至此真正产生
 *
 *对象的内存布局：
 *对象在内存中的布局分为三个区域：对象头(Header)、实例数据(Instance data)和对象
 *填充(padding)
 *1、对象头：两部分信息：第一部分存储对象自身的运行时数据，如哈希码。gc分代年龄、锁状态标志
 *线程持有的锁、偏向线程id和偏向时间戳等，这部分数据在32位和64位的虚拟机中分别为32位和64位
 *。对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个
 *对象是哪个类的实例，
 *2、实例数据：对象真正存储的有效信息，程序代码中所定义的各种类型的字段信息
 *3、对齐填充并不是必要的，起到的是填充作用，一些jvm中要求对象的大小必须是8的整数倍，因此需要
 *一些填充字段
 *
 *对象的访问定位：
 *句柄：jvm会在堆中分配一部分内存作为句柄池，栈中的reference指向对象的句柄地址，而句柄地
 *址包含了指向对象实例数据和对象类型数据的指针
 *直接指针：reference直接指向堆中的对象实例数据，实例数据中包含了指向方法区对象类型数据
 *的指针
 *
 *
 */
public class TestObject{

}
